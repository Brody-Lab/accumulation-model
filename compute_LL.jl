function compute_LL(data, params)

# Set up variables
NLL = 0;
if length(params) == 8
    bias  = params[7];
    lapse = params[8];
elseif length(params) == 7
#    bias  = params[6];
#    lapse = params[7];
    bias = params[7];
    lapse = 0;
else
    bias  = params[5];
    lapse = params[6];
end

# iterate over trials
for i=1:length(data["pokedR"])
    ma,va = compute_trial(data,i,params);

    # compute pr, pl with bias
    pr = 0.5*(1+erf( -(bias-ma)/sqrt(2*va)));
    pl = 1-pr;

    # compute pr, pl with lapse
    PR = (1-lapse)*pr + lapse*0.5;
    PL = (1-lapse)*pl + lapse*0.5;


    # checking for log() stability
#    if PR == 0
#        PR = eps();
#    end
#    if PL == 0
#        PL = eps();
#    end

    # compute NLL for this trial
    if data["pokedR"][i]==1 
        nll = -log(PR);
    else
        nll = -log(PL);
    end
    
    # add to total over all trials
    NLL += nll;
end

# exponential prior
#on brodycomp: sum(p.prior.*params)
# prior: 0.31, 0.94
#NLL += params[2]*0.31 + params[4]*0.94;

# Gaussian prior
# on brodycomp: params(2)^2/(2*p.prior(2)^2) + params(4)^2/(2*p.prior(4)^2);
# prior: 5.39, 1.87
NLL += (params[2]^2)/(2*5.39^2) + (params[4]^2)/(2*1.87^2);

### HACK ALERT for high gamma rats
# prior from H065 fits
#prior     = [0, 5.39,   1.49, 1.87,       0.14,      0.0040,      0,      0];
#mean_prior= [0, 0,      7.91, 0,          0.064,      0.019,      0,      0];
# prior from H067 fits
#prior     = [0, 5.39,   0.49, 1.87,       0.065,      0.026,      0,      0];
#mean_prior= [0, 0,      2.40, 0,          0.22,       0.095,      0,      0];

#NLL += (params[2]^2)/(2*5.39^2) + (params[4]^2)/(2*1.87^2) + (params[5] - mean_prior[5])^2/(2*prior[5]^2) + (params[6]-mean_prior[6])^2/(2*prior[6]^2) + (params[3]-mean_prior[3])^2/(2*prior[3]^2);

return NLL
end



function compute_trial(data, i, params);
    # just a check to handle empty arrays generated by synthetic sampling
    if length(data["leftbups"][i]) == 0
        data["leftbups"][i] = [0];
    end
    if length(data["rightbups"][i]) == 0
        data["rightbups"][i] = [0];
    end

    # run clicks through the adaptation process  
    if length(params) == 8
        cl, cr = make_adapted_cat_clicks(data["leftbups"][i], data["rightbups"][i], params[5],params[6]);
    elseif length(params) == 7
#        cl, cr = make_adapted_cat_clicks(data["leftbups"][i], data["rightbups"][i], params[4],params[5]);
        cl, cr = make_adapted_cat_clicks(data["leftbups"][i], data["rightbups"][i], params[5],params[6]);
    elseif length(params) == 6;
        cl, cr = make_adapted_cat_clicks(data["leftbups"][i], data["rightbups"][i], params[3],params[4]);
    end

    clicks = [-cl cr];
    times = [data["leftbups"][i] data["rightbups"][i]];

    # compute mean of distribution
    mean_a = 0;
    for j=1:length(clicks)
        mean_a += clicks[j]*exp(params[1]*(data["T"][i]-times[j]));
    end

    # compute variance of distribution
    # three sources: initial (params[4]), accumulation (params[2]), and per-click (params[3])
    
    if length(params) == 8
        a_var    = params[2];
        c_var    = params[3];
        init_var = params[4];
    elseif length(params) == 7
#        a_var    = params[2];
#        c_var    = params[3];
#        init_var = 0;
        a_var    = params[2];
        c_var    = params[3];
        init_var = params[4];
    elseif length(params) == 6
        a_var    = 0;;
        c_var    = params[2];
        init_var = 0;
    end
    
    # Initial and accumulation variance
    if abs(params[1]) < 1e-10
        s2 = init_var*exp(2*params[1]*data["T"][i]) + a_var*data["T"][i];
    else
        s2 = init_var*exp(2*params[1]*data["T"][i]) + (a_var/(2*params[1]))*(exp(2*params[1]*data["T"][i])-1);
    end
    
    # add per-click variance
    for j=1:length(clicks)
        s2 += c_var*abs(clicks[j])*exp(2*params[1]*(data["T"][i] - times[j]));
    end

    var_a = s2;

    # return mean and variance of distribution
    return mean_a, var_a
end


# Adaptation function with separate within and across stream adaptation
function make_adapted_clicks(leftbups, rightbups, phi, tau_phi, psi, tau_psi)
    Lsame = ones(typeof(phi),size(leftbups));
    Rsame = ones(typeof(phi),size(rightbups));
    
    # magnitude of stereo clicks set to zero
    if ~isempty(leftbups) && ~isempty(rightbups) && abs(leftbups[1]-rightbups[1]) < eps()
        Lsame[1] = 0;
        Rsame[1] = 0;
    end;
    
    # if there's appreciable same-side adaptation
    if abs(phi - 1) > eps() 
        # inter-click-intervals
    #    ici_L = diff(leftbups')';
    #    ici_R = diff(rightbups')';
        if length(leftbups) <= 1
            ici_l = [];
        else
            ici_L = (leftbups[2:end]  - leftbups[1:end-1])';
        end
    
        if length(rightbups) <= 1
            ici_R = [];
        else
            ici_R = (rightbups[2:end]  - rightbups[1:end-1])';
        end
        
        for i = 2:length(leftbups),
            last_L = tau_phi*log(1-Lsame[i-1]*phi);
            Lsame[i] = 1 - exp((-ici_L[i-1] + last_L)/tau_phi);
        end;
        
        for i = 2:length(rightbups),
            last_R = tau_phi*log(1-Rsame[i-1]*phi);
            Rsame[i] = 1 - exp((-ici_R[i-1] + last_R)/tau_phi);
        end;
        
        Lsame = real(Lsame);
        Rsame = real(Rsame);
    end;
    
    Lother = ones(size(leftbups));
    Rother = ones(size(rightbups));
    
    # if there's appreciable across-side adaptation
    if abs(psi - 1) > eps() 
    #    lefts  = [leftbups(:)  -ones(numel(leftbups),1)];
    #    rights = [rightbups(:) +ones(numel(rightbups),1)];
    #    allbups = sortrows([lefts; rights])'; % one bup in each col, second row has side bup was on
    #    
    #    adapted = ones(1,size(allbups,2)); 
    #    nclicks = ones(size(adapted)); 
    #    
    #    # now let's go through and figure all the across-side adaptive effects
    #    for c = 1:size(allbups,2)-1,
    #        if allbups(2,c)~=allbups(2,c+1), % if this bup and the next are on opposite sides
    #            dt = allbups(1,c+1) - allbups(1,c);
    #            if dt <= cross_side_suppression,
    #                adapted(c) = 0;
    #                adapted(c+1) = 0;
    #                nclicks(c) = 0.5;
    #                nclicks(c+1) = 0.5;
    #            else
    #                # strength of the cross-side adaptation is weighed by the
    #                # magnitude of the preceeding click
    #                adapted(c+1) = 1 - exp(-dt/tau_psi + log(1 - (adapted(c)*(psi-1)+1)));
    #            end;
    #        end;
    #    end;
    #    
    #    
    #    Lother = real(adapted(allbups(2,:)==-1));
    #    Rother = real(adapted(allbups(2,:)==+1));
    #    Lnclicks = nclicks(allbups(2,:)==-1);
    #    Rnclicks = nclicks(allbups(2,:)==+1);
        println("you didn't implement the cross-stream adaptation system yet!!!!!")
        Lnclicks = ones(size(leftbups));
        Rnclicks = ones(size(rightbups));
    else
        Lnclicks = ones(size(leftbups));
        Rnclicks = ones(size(rightbups));
    end
    
    
    # now take the product of the two effects:
    L = Lsame .* Lother;
    R = Rsame .* Rother;
    return L, R
end


## Adaptation function with both within stream and across stream adaptation
#function make_adapted_cat_clicks(leftbups, rightbups, phi, tau_phi)
#    cross_side_suppression = 0;
#    
#    if abs(phi - 1) > eps()
#        lefts  = [leftbups;  -ones(1,length(leftbups))];
#        rights = [rightbups; +ones(1,length(rightbups))];
#        allbups = sortrows([lefts rights]')'; # one bup in each col, second row has side bup was on
#
#        if length(allbups) <= 1
#            ici = [];
#        else
#            ici = (allbups[1,2:end]  - allbups[1,1:end-1])';
#        end     
#
#        adapted = ones(typeof(phi), 1, size(allbups,2));
#               
#        for i = 2:size(allbups,2)
#            if ici[i-1] <= cross_side_suppression
#                adapted[i-1] = 0;
#                adapted[i] = 0;
#            else
#                last = tau_phi * log(1 - adapted[i-1]*phi);
#                adapted[i] = 1 - exp((-ici[i-1] + last)/tau_phi);
#            end
#        end
#    
#    	adapted = real(adapted);
#    
#    	L = adapted[allbups[2,:] .==-1]';
#    	R = adapted[allbups[2,:] .==+1]';
#    else
#    	# phi was equal to 1, there's no adaptation going on.
#    	L = leftbups;
#    	R = rightbups;
#    end
#
#    return L, R
#end

# Adaptation function with both within stream and across stream adaptation
function make_adapted_cat_clicks(leftbups, rightbups, phi, tau_phi)
    
    if abs(phi - 1) > eps()
        lefts  = [leftbups;  -ones(1,length(leftbups))];
        rights = [rightbups; +ones(1,length(rightbups))];
        allbups = sortslices([lefts rights]',dims=1)'; # one bup in each col, second row has side bup was on

        if length(allbups) <= 1
            ici = [];
        else
            ici = (allbups[1,2:end]  - allbups[1,1:end-1])';
        end     

        adapted = ones(typeof(phi), 1, size(allbups,2));
               
        for i = 2:size(allbups,2)
            if ici[i-1] <= 0
            adapted[i-1] = 0;
            adapted[i] =0;
            else
#            last = tau_phi * log(1 - adapted[i-1]*phi);
#            adapted[i] = 1 - exp((-ici[i-1] + last)/tau_phi);
            adapted[i] = 1+ exp(-ici[i-1]/tau_phi)*(adapted[i-1]*phi -1);
            end
        end
    
    	adapted = real(adapted);
    
    	L = adapted[allbups[2,:] .==-1]';
    	R = adapted[allbups[2,:] .==+1]';
    else
    	# phi was equal to 1, there's no adaptation going on.
    	L = leftbups;
    	R = rightbups;
    end

    return L, R
end
